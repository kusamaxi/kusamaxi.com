```bash
cat > hypercarcinisation-into-rustaceans.md << 'EOF'
layout: ~/layouts/PostLayout.astro
draft: false
title: The Hypercarcinisation of Developers
date: 2023-03-24
description: From Monkeys to Rust Programming Crabs
tags:
  - rust
  - hypercarcinisation
  - rustacean
---
![Hypercarcinisation](/assets/post/hypercarcinisation-into-rustaceans/rustacean2.webp)

## From Monkeys to Rust Programming Crabs

In the depths of the ocean, there's a fascinating evolutionary phenomenon known as
hypercarcinisation. It's a process where crustaceans - a group of animals that includes crabs,
lobsters, and shrimp - independently evolve to adopt a crab-like form multiple times. Much like the
crabs scuttling on the ocean floor, an analogous transformation is taking place in the world of
software development, as programmers gravitate toward Rust, a programming language steadily gaining
in popularity.

On the surface, it might seem odd to draw parallels between the evolutionary pathways of crabs and
the career trajectories of developers. But as we dive deeper, it becomes apparent that the same
factors that drive hypercarcinisation in crustaceans are also pushing programmers to embrace Rust.
Much like the crab's compact, protected body and efficient locomotion, Rust offers developers a set
of features that make it an increasingly attractive choice in the face of the challenges posed by
modern computing.

![Rust developer](/assets/post/hypercarcinisation-into-rustaceans/rustacean.webp)

In the realm of crustaceans, the crab-like form has emerged as a winning design. Its hard
exoskeleton offers protection from predators, while its versatile limbs enable it to explore and
thrive in a wide range of environments. It's no coincidence that, through the pressures of natural
selection, a diverse array of crustacean species have independently converged on this remarkably
successful body plan.

Similarly, Rust's design principles address many of the issues that have long plagued developers in
other programming languages. Its focus on safety, performance, and concurrency make it an appealing
choice for those grappling with complex, large-scale software projects. In many ways, Rust can be
seen as the crab-like form of the programming world, offering developers the tools they need to
navigate the ever-evolving landscape of modern software development.

The transition to Rust is not without its challenges. Learning a new language can be a daunting
task, and the Rust community is still growing. However, much like the crustaceans that found success
in their crab-like forms, developers who embrace Rust stand to reap the rewards of its unique
features. As they do so, they contribute to a convergent evolution in the software development
ecosystem - a hypercarcinisation of developers, if you will.

![Rustacean at work](/assets/post/hypercarcinisation-into-rustaceans/rustacean4.webp)

Let's examine a practical example demonstrating Rust's async capabilities: a concurrent HTTP server
that handles multiple requests simultaneously without blocking.

```rust
use hyper::{Body, Request, Response, Server};
use hyper::service::{make_service_fn, service_fn};
use std::convert::Infallible;

async fn handle_request(_req: Request<Body>) -> Result<Response<Body>, Infallible> {
    tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;
    Ok(Response::new(Body::from("Hello, world!")))
}

#[tokio::main]
async fn main() {
    let addr = ([127, 0, 0, 1], 8888).into();

    let make_svc = make_service_fn(|_conn| async {
        Ok::<_, Infallible>(service_fn(handle_request))
    });

    let server = match Server::try_bind(&addr) {
        Ok(builder) => builder.serve(make_svc),
        Err(e) => {
            eprintln!("failed to bind to {}: {}", addr, e);
            return;
        }
    };

    println!("listening on http://{}", addr);

    if let Err(e) = server.await {
        eprintln!("server error: {}", e);
    }
}
```

The `#[tokio::main]` macro transforms our async main function into a proper entry point, creating a
multi-threaded runtime that manages all asynchronous operations. This eliminates the need to
manually construct a runtime - the macro handles all the boilerplate.

The `make_service_fn` creates a service factory that runs once per connection. Its closure receives
connection metadata (which we ignore with `_conn`) and returns a future that resolves to a service.
Inside, `service_fn` wraps our `handle_request` function, converting it into a type that implements
hyper's Service trait.

The async closure `async { Ok::<_, Infallible>(service_fn(handle_request)) }` creates a future that
immediately resolves. The turbofish notation `<_, Infallible>` helps the compiler infer the complete
`Result<Service, Infallible>` type. `Infallible` is a zero-variant enum that proves at the type
level that service creation cannot fail - the compiler can eliminate all error-handling paths
entirely.

When we `await` the server, control yields to tokio's work-stealing scheduler. The runtime
multiplexes all connections across its thread pool. Each incoming request spawns its own task, so
the 2-second sleep in one request doesn't block others - they execute concurrently. The flow: bind
socket → accept connection → run factory closure → create service → handle requests concurrently on
the scheduler.

### Safety Rust's ownership system prevents data races at compile time. Multiple concurrent requests
can't create race conditions because the type system enforces safe sharing. If you try to share
mutable state unsafely, the code won't compile.

### Performance Zero-cost abstractions mean this async code compiles down to efficient state
machines. Tokio's scheduler distributes work across CPU cores without OS thread overhead. Each await
point becomes a simple state transition - no stack allocation, no context switching.

### Ease of use The async/await syntax reads like synchronous code but executes asynchronously. No
callback pyramids, no manual future composition. Error handling uses standard Result types. The type
system guides you - if it compiles, concurrency is correct.

![Rustacean moprhing](/assets/post/hypercarcinisation-into-rustaceans/rustacean3.webp)

It's a brave new world out there, both beneath the waves and above the keyboard. As the tendrils of
technology continue to intertwine with our lives, developers must adapt and evolve. By taking
inspiration from the crabs' remarkable story of hypercarcinisation, we can appreciate the forces
that drive the Rust revolution and embrace the opportunities it presents. So, as you ponder the
future of your programming career, consider following in the footsteps (or should I say, pincers) of
the crustaceans, and explore the uncharted waters of Rust. Who knows what evolutionary advantages
await you in this new, crab-like programming world?
