---
layout: ~/layouts/PostLayout.astro
draft: false
title: Hardest thing in systems design
date: 2025-08-31
description: I've been wondering why JAM decided not to use NOMT
tags:
- polkadot
- jam
- nomt
- patricia
---

## why doesn't jam use nomt?

been wondering since rob's sub0 talk.

<div style="position:relative; width:100%; padding-bottom:56.25%; height:0;">
  <iframe
    src="https://www.youtube.com/embed/N3BX2eTqpro"
    title="YouTube video player"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    allowfullscreen
    style="position:absolute; top:0; left:0; width:100%; height:100%;"
  ></iframe>
</div>

nomt is elegant - optimized for ssds, reduces writes, keeps hot data in memory. the kind of
engineering that feels right.

jam uses the dumbest possible binary patricia trie: go left on 0, right on 1. no optimizations. no
cleverness.

at first i thought drama. turns out i was demanding elegance where simplicity was the feature.

## consensus demands determinism

blockchain consensus isn't about speed. it's about identical execution across every node -
bit-for-bit identical on raspberry pis and $50k servers.

nomt's optimizations are performance decisions: when to allocate, when to flush cache, how to batch.
in consensus, each decision point is a potential fork where implementations diverge. divergence
means network splits or slashing.

jam's binary trie has zero decisions:

```julia
# lookup in jam's binary patricia trie
const ZERO_HASH = zeros(UInt8, 32)

function lookup(state_root::Vector{UInt8}, key::Vector{UInt8})::Union{Vector{UInt8}, Nothing}
    key_bits = bytes_to_bits(key)  # 31 bytes -> 248 bits
    node_hash = state_root
    depth = 0
    
    while node_hash != ZERO_HASH
        node = fetch_node(node_hash)  # db lookup by hash
        
        if is_leaf(node)
            stored_key, value = decode_leaf(node)
            return stored_key == key ? value : nothing
        end
        
        # branch: follow bit
        left_hash, right_hash = decode_branch(node)
        node_hash = key_bits[depth + 1] ? right_hash : left_hash
        depth += 1
    end
    
    nothing
end

# helpers
bytes_to_bits(b::Vector{UInt8}) = BitVector([((b[iÃ·8 + 1] >> (7 - i%8)) & 1) == 1 for i in 0:length(b)*8-1])
is_leaf(node::Vector{UInt8}) = (node[1] & 0x80) != 0  # first bit set
```

no edge cases. no optimization paths. hundreds of teams in dozens of languages will produce
identical results.

## bottleneck analysis

jam handles ~1M db ops/sec. needs ~10k. actual bottlenecks:
- 10M gas units per work item
- 2MB/s data per core

storage isn't the constraint. optimizing it is optimizing the wrong layer.

## where nomt fits

validators verify computation, not storage. work packages include merkle proofs against consensus
state root. validators check proofs using the simple trie - never touch service state.

services run nomt locally to:
- query application state quickly
- build work packages with merkle proofs
- serve end users
- maintain application-specific indexes

clever database (nomt) interfaces with stupid consensus (binary trie). performance where needed,
determinism where required.

nomt isn't competing with jam's trie. it's the fast local database that services use to participate
in jam's consensus.

## the point

consensus needs algorithms so simple that diverse implementations converge. nomt is beautiful
engineering from the industry's [best talent](https://thrum.dev). it solves real problems elegantly.

but consensus doesn't need beautiful. it needs boring.

the hardest thing in systems design isn't knowing how to optimize. it's knowing when not to.
